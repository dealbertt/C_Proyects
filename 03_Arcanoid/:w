#include "header/collisions.h"
#include "header/graphics.h"
#include "header/logic.h"
#include <SDL2/SDL_surface.h>
#include <SDL2/SDL_timer.h>
#include <SDL2/SDL_video.h>

//NOTE: The x and y positions of rects indicate the top left corner
//Idea behind the collisions
//based on the delta apply a "layer" on the side of the ball that is necessary
//
//  lets say this is the top side of the "ball"(even though its a square but whatever) 
//          ||
//           V 
//  [][][][][][][][][][] this are supposed to be boxes that check the color. if its anything than black, a collision has happened
//  -------------------- 
//  some progress, i still need to figure out how this guys are going to figure out the color tho
bool checkCollisions(SDL_Surface *surface, BALL *ball,SDL_Window *window){
    //check the ball delta to determine where the bits need to be positioned
    LAYER *layer = malloc(sizeof(LAYER));
    if(layer == NULL){
        perror("Error allocating memory for Collision Layer\n");
        return false;
    }
    for(int i = 0; i < 5; i++){
        layer->bits[i] = false;
    }
    assingCheckers(ball,surface,window);



    return false;
}

int assingCheckers(BALL *ball,SDL_Surface *surface,SDL_Window *window){
    //this whole thing does not make any sense :)
    //corners only have 4 checkers insted of 5
    if(ball->deltaX == 0 && ball->deltaY > 0){
        //moving only up
        getColorData(window,ball,ball ->x,ball->y + 10,CHECK_SIZE,CHECK_SIZE,0);
        getColorData(window,ball, ball ->x + CHECK_SIZE ,ball->y + 10,CHECK_SIZE,CHECK_SIZE,1);
        getColorData(window,ball,ball ->x + (CHECK_SIZE * 2),ball->y + 10, CHECK_SIZE,CHECK_SIZE,2);
        getColorData(window,ball,ball ->x + (CHECK_SIZE * 3),ball->y + 10 ,CHECK_SIZE,CHECK_SIZE,3);
        getColorData(window,ball,ball ->x + (CHECK_SIZE * 4),ball->y + 10 ,CHECK_SIZE,CHECK_SIZE,4);
        //checks for colllisions i guess
        return 1;
    }else if(ball->deltaX == 0 && ball->deltaY < 0){
        //moving only down
        ball->layer->checkers[0] = (SDL_Rect){ball ->x,ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[1] = (SDL_Rect){ball ->x + CHECK_SIZE ,ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[2] = (SDL_Rect){ball ->x + (CHECK_SIZE * 2),ball->y + BRICK_HEIGHT, CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[3] = (SDL_Rect){ball ->x + (CHECK_SIZE * 3),ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[4] = (SDL_Rect){ball ->x + (CHECK_SIZE * 4),ball->y + CHECK_SIZE ,CHECK_SIZE,CHECK_SIZE,};
    }else if(ball->deltaX < 0 && ball->deltaY > 0){
        //moving to the left and up
        ball->layer->checkers[0] = (SDL_Rect){ball ->x,ball->y - CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[1] = (SDL_Rect){ball ->x + CHECK_SIZE ,ball->y - CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[2] = (SDL_Rect){ball ->x - CHECK_SIZE,ball->y, CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[3] = (SDL_Rect){ball ->x - CHECK_SIZE,ball->y + CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[4] = (SDL_Rect){ball ->x - CHECK_SIZE,ball->y - CHECK_SIZE ,CHECK_SIZE,CHECK_SIZE,};
    }else if(ball->deltaX < 0 && ball->deltaY < 0){
        //moving to the left and down
        ball->layer->checkers[0] = (SDL_Rect){ball ->x - CHECK_SIZE,ball->y + (BRICK_HEIGHT - (CHECK_SIZE * 2)),CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[1] = (SDL_Rect){ball ->x - CHECK_SIZE,ball->y + (BRICK_HEIGHT - CHECK_SIZE),CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[2] = (SDL_Rect){ball ->x - CHECK_SIZE,ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[3] = (SDL_Rect){ball ->x,ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[4] = (SDL_Rect){ball ->x + CHECK_SIZE,ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
    
    }else if(ball->deltaX > 0 && ball->deltaY < 0){
        //moving to the right and down
        ball->layer->checkers[0] = (SDL_Rect){ball ->x + (BRICK_WIDTH - CHECK_SIZE * 2),ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[1] = (SDL_Rect){ball ->x + (BRICK_WIDTH - CHECK_SIZE),ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[2] = (SDL_Rect){ball ->x + BRICK_WIDTH,ball->y + BRICK_HEIGHT,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[3] = (SDL_Rect){ball ->x + BRICK_WIDTH,ball->y + BRICK_HEIGHT - CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[4] = (SDL_Rect){ball ->x + BRICK_WIDTH,ball->y + (BRICK_HEIGHT - CHECK_SIZE * 2),CHECK_SIZE,CHECK_SIZE,};
    
    }else if(ball->deltaX > 0 && ball->deltaY > 0){
        //moving to the right and up
        ball->layer->checkers[0] = (SDL_Rect){ball ->x + (BRICK_WIDTH - CHECK_SIZE * 2),ball->y - CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[1] = (SDL_Rect){ball ->x + (BRICK_WIDTH - CHECK_SIZE),ball->y - CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[2] = (SDL_Rect){ball ->x + BRICK_WIDTH,ball->y - CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[3] = (SDL_Rect){ball ->x + BRICK_WIDTH,ball->y,CHECK_SIZE,CHECK_SIZE,};
        ball->layer->checkers[4] = (SDL_Rect){ball ->x + BRICK_WIDTH,ball->y + CHECK_SIZE,CHECK_SIZE,CHECK_SIZE,};
    }
    return 0;

}
int getColorData(SDL_Window *window, BALL *ball, int startX, int startY,int width,int height,int index){
    SDL_Surface *surface = SDL_GetWindowSurface(window);
    if(surface == NULL){
        printf("Error trying to get the surface from window");
        return -1;
    }
    SDL_LockSurface(surface);
      for (int y = startY; y < startY + height; ++y) {
        for (int x = startX; x < startX + width; ++x) {
            // Make sure the coordinates are within the surface bounds
            if (x >= 0 && x < surface->w && y >= 0 && y < surface->h) {
                // Get the pixel value
                Uint32 pixel = ((Uint32*)surface->pixels)[y * surface->w + x];

                // Extract the RGBA values
                Uint8 r, g, b, a;
                SDL_GetRGBA(pixel, surface->format, &r, &g, &b, &a);

                // Output the color of the pixel
                int totalColor = r + g + b;
                if(totalColor != 0){
                    ball->layer->bits[index] = true;
                    printf("Color at (%d, %d): R=%d, G=%d, B=%d, A=%d\n", x, y, r, g, b, a);
                    SDL_Delay(500);
                    return 1;
                }
            }
        }
    }
    SDL_UnlockSurface(surface);



    return 0;
}
